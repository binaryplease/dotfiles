* Repositories
  From here-on out =use-package= loads packages. We almost always want to =:ensure= packages are present.
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    (require 'use-package)
    (setq use-package-always-ensure t)
  #+END_SRC

* General Options
  Start by setting some personal information. I use password-store as my
  goto-password-manager, emacs supports it without plugins since version 26.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq user-full-name "Pablo Ovelleiro Corral"
          user-mail-address "pablo1@mailbox.org"
          mail-host-address "mailbox.org"
          mail-default-reply-to "pablo@mailbox.org")

    (require 'auth-source-pass)
    (auth-source-pass-enable)
  #+END_SRC

  Use UTF-8 by default. I don't see why utf-8 should not be used everywhere as
  most systems support it.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (prefer-coding-system        'utf-8)
    (set-language-environment    'utf-8)
    (set-default-coding-systems  'utf-8)
    (set-terminal-coding-system  'utf-8)
    (set-selection-coding-system 'utf-8)
  #+END_SRC

 Backup files are created on save in the same directory as the file and end in
  ~. They can be numbered which makes most sense combined with a different save
  location and automatic pruning. Autosave files are created between saves after
  a sufficient timeout in the current directory for crash detection, they begin
  and end with #. Let’s change their save location as well.
  #+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq version-control t)
(setq delete-old-versions t)
(setq auto-save-list-file-prefix "~/.emacs.d/autosave/")
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
  #+END_SRC

  Establish an indentation and whitespace standard I follow. Trailing whitespace
  is deleted on saving, this might cause problems someday and break a file, but
  I have yet to come across a case where it happens.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq standard-indent 2)
    (setq-default tab-width 2)
    (setq-default indent-tabs-mode nil)
    (setq show-trailing-whitespace t)
    (setq sentence-end-double-space nil)
    (setq default-fill-column 80)
    (add-hook 'before-save-hook 'delete-trailing-whitespace)
  #+END_SRC

  Default scrolling settings confuse me, as I keep loosing the line on which the
  point is. Setting the scroll margin higher scrolls "sooner" and gives a bit
  more context.
#+BEGIN_SRC emacs-lisp
  (setq-default scroll-margin 5
          scroll-conservatively 0
          scroll-up-aggressively 0.01
          scroll-down-aggressively 0.01)
#+END_SRC

  Asking for confirmation when closing an unsaved file seems like a good idea.
  But entering 'y' or 'n' is enough
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Some settings to start with a notes org-mode file. I have disabled them for now
as I like the rather useless but good-looking dashboard

#+BEGIN_SRC emacs-lisp
  ;; (setq remember-notes-initial-major-mode 'org-mode)
  ;; (setq remember-data-file "~/org/notes.org")
  ;; (setq initial-buffer-choice 'remember-notes)
  (let ((default-directory  "~/.emacs.d/lisp/"))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

If you type part of keybind, Emacs will display this part in the echo area after
a timeout. One second is a bit too long though for my taste.
#+BEGIN_SRC emacs-lisp
 (setq echo-keystrokes 0.1)
#+END_SRC

Memory Management. Let’s allow more than 800 KiB cache before starting garbage
collection.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 50000000)
#+END_SRC

Save clipboard data of other programs in the kill ring when possible
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

I like starting in the same place in a file as I left it on the next visit
#+BEGIN_SRC emacs-lisp
(setq-default save-place t)
(setq save-place-file "~/.emacs.d/saveplace")
#+END_SRC


If TRAMP makes backup files, they should better be kept locally than remote.
#+BEGIN_SRC emacs-lisp
(setq tramp-backup-directory-alist backup-directory-alist)

(customize-set-variable 'tramp-default-method "ssh")

#+END_SRC



* Evil


 The extensible vi layer for Emacs. As a vim-refugee I try to enable evil-mode
 in as many places as I can.

** [[https://github.com/emacs-evil/evil][evil-mode]]
   #+BEGIN_SRC emacs-lisp
          (use-package evil
            :ensure t
            :init
      (setq evil-want-integration t)
      (setq evil-want-keybinding nil)
                      :config (progn
                                (evil-mode 1)                                                         ;; Enable evil mode everywhere
                                (define-key evil-normal-state-map (kbd ";") 'evil-ex)                 ;; Swap ; and : for easier command entering (normal mode)
                                (define-key evil-visual-state-map (kbd ";") 'evil-ex)                 ;; Swap ; and : for easier command entering (visual mode)
                                (define-key evil-motion-state-map (kbd ":") 'evil-repeat-find-char))) ;; I don't use this much, but map it for completeness


     ;; (with-eval-after-load 'evil-maps
     ;;   (define-key evil-insert-state-map (kbd "RET") 'newline-and-indent))

   #+END_SRC

** [[https://github.com/emacs-evil/evil-collection][evil-collection]]
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-collection
       :after evil
       :ensure t
       :custom
       (evil-collection-setup-minibuffer t)
       :config
       (setq evil-collection-mode-list (delete 'dired evil-collection-mode-list))
       (evil-collection-init))
   #+END_SRC

** [[https://github.com/Somelauw/evil-org-mode][evil-org]]
   Evil bindings for org-mode
   #+BEGIN_SRC emacs-lisp
     (use-package evil-org
       :ensure t
       :after org
       :after evil
       :config
       (add-hook 'org-mode-hook 'evil-org-mode)
       (add-hook 'evil-org-mode-hook
                 (lambda ()
                   (evil-org-set-key-theme)))
       (require 'evil-org-agenda)
       (evil-org-agenda-set-keys))
   #+END_SRC

** [[https://github.com/emacs-evil/evil-magit][evil-magit]]
   Evil keybingings for magit
   #+BEGIN_SRC emacs-lisp :tangle yes
         (use-package evil-magit)
   #+END_SRC

** [[https://github.com/linktohack/evil-commentary][evil-commentary]]
   Toggle comments in evil-mode
   #+BEGIN_SRC emacs-lisp
     (use-package evil-commentary
       :after evil
       :ensure t
       :config
       (evil-commentary-mode))
   #+END_SRC

* LSP
** [[https://github.com/emacs-lsp/lsp-ui][lsp-ui]]
   This contains all the higher level UI modules of lsp-mode, like flycheck support and code lenses.
** [[https://github.com/tigersoldier/company-lsp][company-lsp]]
  #+BEGIN_SRC emacs-lisp
      (use-package lsp-mode
        :ensure t
        :init (setq lsp-inhibit-message t
                    lsp-eldoc-render-all nil
                    lsp-highlight-symbol-at-point nil))


     (add-hook 'after-init-hook #'global-flycheck-mode)
      (use-package company-lsp
        :after  company
        :ensure t
        :config
        (setq company-lsp-enable-snippet t
              company-lsp-cache-candidates t))

    ;; (push 'company-lsp company-backends)

      (use-package lsp-ui
        :ensure t
        :config
        (setq lsp-ui-sideline-enable t
              lsp-ui-sideline-show-symbol t
              lsp-ui-sideline-show-hover t
              lsp-ui-flycheck-enable t
              lsp-ui-imenu-enable t
         ;; lsp-ui-doc-enable nil
         ;; lsp-ui-sideline-ignore-duplicate t
              lsp-ui-sideline-show-code-actions t
              lsp-ui-sideline-update-mode 'point))

  #+END_SRC
** [[https://github.com/emacs-lsp/lsp-java][lsp-java]]
   lsp-mode support for java
   #+BEGIN_SRC emacs-lisp
   (use-package lsp-java :ensure t :after lsp
     :config (add-hook 'java-mode-hook 'lsp))
   #+END_SRC

* Filetypes
** config-general-mode, general unix files
   #+BEGIN_SRC emacs-lisp
   (use-package config-general-mode
   :ensure t
   :mode ("\\.conf$" "\\.*rc$"))



 (use-package ssh-config-mode
   :ensure t
   :mode ("/\\.ssh/config\\'" "/system/ssh\\'" "/sshd?_config\\'" "/known_hosts\\'" "/authorized_keys2?\\'")
   :hook (ssh-config-mode . turn-on-font-lock)

   :config
   (autoload 'ssh-config-mode "ssh-config-mode" t))



 (use-package logview
   :ensure t
   :mode ("syslog\\(?:\\.[0-9]+\\)" "\\.log\\(?:\\.[0-9]+\\)?\\'"))


 (use-package yaml-mode
   :ensure t
   :mode (".yaml$"))

 (use-package yaml-tomato
   :ensure t)

 (use-package vimrc-mode
   :ensure t
   :mode ("^\\.vimrc\\'"))
   #+END_SRC



** graphviz
    #+BEGIN_SRC emacs-lisp

(use-package graphviz-dot-mode
  :ensure t
  :init
  (defvar default-tab-width nil)

  :mode ("\\.dot\\'"))

    #+END_SRC


** Latex Export

#+BEGIN_SRC emacs-lisp
;; Include the latex-exporter
(require 'ox-latex)
;; Add minted to the defaults packages to include when exporting.
(add-to-list 'org-latex-packages-alist '("" "minted"))
;; Tell the latex export to use the minted package for source
;; code coloration.
(setq org-latex-listings 'minted)
;; Let the exporter use the -shell-escape option to let latex
;; execute external programs.
;; This obviously and can be dangerous to activate!
(setq org-latex-pdf-process
      '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq org-latex-minted-options
'(("frame" "lines") ("breaklines" "true")  ("frame" "single") ))

#+END_SRC



* Completion and snippets
** [[https://github.com/abo-abo/swiper][ivy/swiper/counsel]]
    Use ivy for selecting things, also add recent files and bookmarks to the list and set a custom date format.
    #+BEGIN_SRC emacs-lisp

(use-package ivy
  :ensure t
  :config
  (ivy-mode)
  (setq ivy-display-style 'fancy
        ivy-use-virtual-buffers t
        enable-recursive-minibuffers t
        ivy-use-selectable-prompt t))




    (use-package counsel :ensure t
      :bind
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)							;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
      (setq ivy-height 10)								;; number of result lines to display
      (setq ivy-count-format "%d/%d ")							;; set a default count format
											;; (setq ivy-initial-inputs-alist nil) ;; no regexp by default
      (setq ivy-re-builders-alist
        '((t   . ivy--regex-fuzzy))))							;; configure regexp engine to use fuzzy finding





(setq counsel-find-file-ignore-regexp
        (concat
         ;; File names beginning with # or .
         "\\(?:\\`[#.]\\)"
         ;; File names ending with # or ~
         "\\|\\(?:\\`.+?[#~]\\'\\)"))

    #+END_SRC

** [[https://github.com/lewang/flx][flx]]
   #+BEGIN_SRC emacs-lisp
     (use-package flx
       :ensure t
       :config
       (setq ivy-initial-inputs-alist nil)
       )
   #+END_SRC
** [[https://github.com/company-mode/company-mode][company-mode]]
   Modular in-buffer completion framework for Emacs
   #+BEGIN_SRC emacs-lisp

     ;; (use-package company-go
     ;;   :ensure t
     ;;   :defer t
     ;;   :init
     ;;   (with-eval-after-load 'company
     ;; (add-to-list 'company-backends 'company-go)))

     (use-package company
       :ensure t
       :config
       (progn
         (setq company-idle-delay 0.2
               company-selection-wrap-around t
               company-dabberv-downcase 0
               company-minimum-prefix-length 1
               company-show-numbers t
               company-tooltip-limit 20)
         (company-tng-configure-default)
         (define-key company-active-map [tab] nil)
         (define-key company-active-map (kbd "TAB") nil)
         )

       ;; Facing
       (unless (face-attribute 'company-tooltip :background)
         (set-face-attribute 'company-tooltip nil :background "black" :foreground "gray40")
         (set-face-attribute 'company-tooltip-selection nil :inherit 'company-tooltip :background "gray15")
         (set-face-attribute 'company-preview nil :background "black")
         (set-face-attribute 'company-preview-common nil :inherit 'company-preview :foreground "gray40")
         (set-face-attribute 'company-scrollbar-bg nil :inherit 'company-tooltip :background "gray20")
         (set-face-attribute 'company-scrollbar-fg nil :background "gray40"))

       ;; Activating globally
       (global-company-mode t)



       (use-package company-quickhelp
         :ensure t
         :after company
         :config
         (company-quickhelp-mode 1))

       (use-package company-quickhelp          ; Documentation popups for Company
         :ensure t
         :defer t
         :init (add-hook 'global-company-mode-hook #'company-quickhelp-mode)
         )
         )
   #+END_SRC


** [[https://github.com/joaotavora/yasnippet][yasnippet]]
   A template system for Emacs
   #+BEGIN_SRC emacs-lisp

     (use-package yasnippet
       :ensure t
       :config
       (progn

         ;; (define-key yas-minor-mode-map (kbd "tab") #'yas-expand)

         ;; Activate global
         (yas-global-mode)))





     (use-package yasnippet-snippets :ensure t)
     (use-package ivy-yasnippet :ensure t)

     (defvar company-mode/enable-yas t
       "Enable yasnippet for all backends.")

     (defun company-mode/backend-with-yas (backend)
       (if
           (or (not company-mode/enable-yas)
               (and (listp backend) (member 'company-yasnippet backend))
               )
           backend
         (append (if (consp backend) backend (list backend))
                 '(:with company-yasnippet))))
     (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
   #+END_SRC

* Org-Mode
  #+BEGIN_SRC emacs-lisp
  (defun ck/org-confirm-babel-evaluate (lang body)
  (not (or (string= lang "latex") (string= lang "dot"))))
(setq org-confirm-babel-evaluate 'ck/org-confirm-babel-evaluate)



(add-hook 'org-mode-hook '(lambda () (setq fill-column 80)))
(add-hook 'org-mode-hook 'turn-on-auto-fill)




(org-babel-do-load-languages
 'org-babel-load-languages
 '((dot . t))) ; this line activates dot

  #+END_SRC
** [[https://github.com/sabof/org-bullets][org-bullets]]
   Make the bullets in org-mode look nicer with UTF-8 characters
   #+BEGIN_SRC emacs-lisp
   (setq org-cycle-separator-lines 0)
   (use-package org-bullets
     :demand
     :config
     (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
   #+END_SRC

* Linting, spellcheck and reformatting
** [[https://github.com/flycheck/flycheck][flycheck]]
   On the fly syntax checking
   #+BEGIN_SRC emacs-lisp
   (use-package flycheck
     :ensure t
     :init (global-flycheck-mode))
   #+END_SRC
** [[https://github.com/lassik/emacs-format-all-the-code][format-all]]
Auto-format source code in many languages with one command
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package format-all
      :ensure t)
    #+END_SRC

* Other tools
  #+BEGIN_SRC emacs-lisp
(setq langtool-language-tool-jar "/usr/share/java/languagetool/languagetool-commandline.jar")

  #+END_SRC
** [[https://github.com/politza/pdf-tools][pdf-tools]]
   #+BEGIN_SRC emacs-lisp :tangle yes

     (use-package pdf-tools
       :ensure t
       :config
       (pdf-tools-install)
       (setq-default pdf-view-display-size 'fit-page)
       ;; (bind-keys :map pdf-view-mode-map
       ;;     ("\\" . hydra-pdftools/body)
       ;;     ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
       ;;     ("g"  . pdf-view-first-page)
       ;;     ("G"  . pdf-view-last-page)
       ;;     ("l"  . image-forward-hscroll)
       ;;     ("h"  . image-backward-hscroll)
       ;;     ("j"  . pdf-view-next-page)
       ;;     ("k"  . pdf-view-previous-page)
       ;;     ("e"  . pdf-view-goto-page)
       ;;     ("u"  . pdf-view-revert-buffer)
       ;;     ("al" . pdf-annot-list-annotations)
       ;;     ("ad" . pdf-annot-delete)
       ;;     ("aa" . pdf-annot-attachment-dired)
       ;;     ("am" . pdf-annot-add-markup-annotation)
       ;;     ("at" . pdf-annot-add-text-annotation)
       ;;     ("y"  . pdf-view-kill-ring-save)
       ;;     ("i"  . pdf-misc-display-metadata)
       ;;     ("s"  . pdf-occur)
       ;;     ("b"  . pdf-view-set-slice-from-bounding-box)
       ;;     ("r"  . pdf-view-reset-slice)
       ;; )
     (use-package org-pdfview :ensure t))
   #+END_SRC

** [[https://magit.vc/][magit]]
   #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package magit
         :ensure t
         :defer t
         ;; :bind (("C-x g" . magit-status))
         ;; :config
         ;; (progn
     ;;       (defun inkel/magit-log-edit-mode-hook ()
     ;;   (setq fill-column 72)
     ;;   (flyspell-mode t)
     ;;   (turn-on-auto-fill))
     ;;       (add-hook 'magit-log-edit-mode-hook 'inkel/magit-log-edit-mode-hook)
     ;;       (defadvice magit-status (around magit-fullscreen activate)
     ;;   (window-configuration-to-register :magit-fullscreen)
     ;;   ad-do-it
     ;;   (delete-other-windows))
     ;;
     ;; )
         )
   #+END_SRC

** [[https://github.com/dgutov/diff-hl][diff-hl]]
   Show git diff gutter
   #+BEGIN_SRC emacs-lisp
   (use-package diff-hl
 :ensure t
 :config
 (global-diff-hl-mode +1)
 (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
 (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
   #+END_SRC

** [[https://github.com/justbur/emacs-which-key][which-key]]
   Emacs package that displays available keybindings in popup
   #+BEGIN_SRC emacs-lisp
   (use-package which-key :demand)
   (which-key-mode)
   #+END_SRC
** [[https://github.com/bbatsov/projectile][projectile]]
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package projectile
       :bind-keymap
       ;; ("C-c p" . projectile-command-map)
       :config
       (setq projectile-project-search-path '("~/Projects/" "~/Documents/" "~/org-files")))
     (projectile-mode +1)
   #+END_SRC
** [[https://github.com/ericdanan/counsel-projectile][counsel-projectile]]
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel-projectile
       :ensure t
       :config
       (counsel-projectile-mode))
   #+END_SRC

* Keybindings
** [[https://github.com/noctuid/general.el][general.el]]
    More convenient key definitions in emacs
    #+BEGIN_SRC emacs-lisp

      (defun kill-other-buffers ()
        "Kill all other buffers."
        (interactive)
        (mapc 'kill-buffer
              (delq (current-buffer)
                    (remove-if-not 'buffer-file-name (buffer-list)))))



      (use-package general
        :ensure t
        :init
        (setq general-override-states '(insert
                                        emacs
                                        hybrid
                                        normal
                                        visual
                                        motion
                                        operator
                                        replace))


        :config
        (general-define-key
         :states '(normal visual insert emacs motion)
         :keymaps 'override
         :prefix "SPC"
         :non-normal-prefix "M-SPC"
         ;; General stuff
         "SPC"	'(counsel-M-x :which-key "M-x")
         "ESC"	'keyboard-quit
         "/"	'(counsel-ag :wich-key "ag")
         "."	'(avy-goto-word-or-subword-1  :which-key "go to word")
         ;; "a"	'(hydra-launcher/body :which-key "Applications")
         "c"	'(:ignore t :which-key "comment")
         "cl"	'(comment-or-uncomment-region-or-line :which-key "comment line")
         ;; "w"	'(hydra-window/body :which-key "Window")

         ;; Files
         "f"	'(:ignore t :which-key "files")
         "fd"	'(counsel-git :which-key "find in git dir")
         "ff"	'(counsel-find-file :which-key "open file")
         "fr"	'(counsel-recentf :which-key "recent-files")
         ;; Configs
         "fc"	'(:ignore t :which-key "Config")
         "fc"	'(:ignore t :which-key "Config")

         ;; "fce"	'(:ignore t :which-key "Config") TODO edit emacs settings org

         ;; Applicartions
         "a"	'(:ignore t :which-key "Applications")
         "g"	'(:ignore t :which-key "Git")
         "gs" '(magit-status :which-key "Git status")


         ;; Org
         "o"	'(:ignore t :which-key "Org")
         "ol" '(org-toggle-link-display :which-key "Toggle link visibility")
         "ov" '(visible-mode :which-key "Toggle visibility")

         ;; Windows
         "w"	'(:ignore t :which-key "Window")
         "wo" '(delete-other-windows :which-key "delete other windows")
         "wd"	'(delete-window :which-key "delete window")
         "ws"	'(split-window-right :which-key "split vertical")
         "wS"	'(split-window-below :which-key "split horizontal")

         ;; Buffers TODO edit, eval..
         "b"	'(:ignore t :which-key "Buffer")
         "bo" '(kill-other-buffers :which-key "Kill other buffers")
         "bd"	'(kill-buffer-and-window :which-key "kill buffer and window")
         "TAB"	'(ivy-switch-buffer :which-key "switch buffer")

         ;; Projects
         "p" '(:ignore t :which-key "Project")
         "pp" '(counsel-projectile :which-key "Switch project")
         "pf" '(counsel-projectile-find-file :which-key "Project file")
         "p/" '(counsel-projectile-ag :which-key "Search project")



         ;; Ever open a file in the wrong window?

         ;; (defun rotate-windows ()
         ;;   "Rotate your windows"
         ;;   (interactive)
         ;;   (cond ((not (> (count-windows)1))
         ;;          (message "You can't rotate a single window!"))
         ;;         (t
         ;;          (setq i 1)
         ;;          (setq numWindows (count-windows))
         ;;          (while  (< i numWindows)
         ;;            (let* (
         ;;                   (w1 (elt (window-list) i))
         ;;                   (w2 (elt (window-list) (+ (% i numWindows) 1)))

         ;;                   (b1 (window-buffer w1))
         ;;                   (b2 (window-buffer w2))

         ;;                   (s1 (window-start w1))
         ;;                   (s2 (window-start w2))
         ;;                   )
         ;;              (set-window-buffer w1  b2)
         ;;              (set-window-buffer w2 b1)
         ;;              (set-window-start w1 s2)
         ;;              (set-window-start w2 s1)
         ;;              (setq i (1+ i)))))))

         ;; This snippet flips a two-window frame, so that left is right, or up is down. It's sanity preserving if you've got a sliver of OCD.

         ;; Annoyed when Emacs opens the window below instead at the side?
         ;; This snippet toggles between horizontal and vertical layout of two windows.
         ;; (defun toggle-window-split ()
         ;;   (interactive)
         ;;   (if (= (count-windows) 2)
         ;;       (let* ((this-win-buffer (window-buffer))
         ;;              (next-win-buffer (window-buffer (next-window)))
         ;;              (this-win-edges (window-edges (selected-window)))
         ;;              (next-win-edges (window-edges (next-window)))
         ;;              (this-win-2nd (not (and (<= (car this-win-edges)
         ;;                                          (car next-win-edges))
         ;;                                      (<= (cadr this-win-edges)
         ;;                                          (cadr next-win-edges)))))
         ;;              (splitter
         ;;               (if (= (car this-win-edges)
         ;;                      (car (window-edges (next-window))))
         ;;                   'split-window-horizontally
         ;;                 'split-window-vertically)))
         ;;         (delete-other-windows)
         ;;         (let ((first-win (selected-window)))
         ;;           (funcall splitter)
         ;;           (if this-win-2nd (other-window 1))
         ;;           (set-window-buffer (selected-window) this-win-buffer)
         ;;           (set-window-buffer (next-window) next-win-buffer)
         ;;           (select-window first-win)
         ;;           (if this-win-2nd (other-window 1))))))





         ;; (defun cleanup-buffer-safe ()
         ;;   "Perform a bunch of safe operations on the whitespace content of a buffer.
         ;; Does not indent buffer, because it is used for a before-save-hook, and that
         ;; might be bad."
         ;;   (interactive)
         ;;   (untabify (point-min) (point-max))
         ;;   (delete-trailing-whitespace)
         ;;   (set-buffer-file-coding-system 'utf-8))

         ;; ;; Various superfluous white-space. Just say no.
         ;; (add-hook 'before-save-hook 'cleanup-buffer-safe)

         ;; (defun cleanup-buffer ()
         ;;   "Perform a bunch of operations on the whitespace content of a buffer.
         ;; Including indent-buffer, which should not be called automatically on save."
         ;;   (interactive)
         ;;   (cleanup-buffer-safe)
         ;;   (indent-region (point-min) (point-max)))

         ;; (global-set-key (kbd "C-c n") 'cleanup-buffer)

         ;; I use these two literally all the time. The first one removes trailing whitespace and replaces all tabs with spaces before save.

         ;; The last one I've got on a key - it also indents the entire buffer.





         ;; C-d on an empty line in the shell terminates the process.

         ;; (defun comint-delchar-or-eof-or-kill-buffer (arg)
         ;;   (interactive "p")
         ;;   (if (null (get-buffer-process (current-buffer)))
         ;;       (kill-buffer)
         ;;     (comint-delchar-or-maybe-eof arg)))

         ;; (add-hook 'shell-mode-hook
         ;;           (lambda ()
         ;;             (define-key shell-mode-map
         ;;               (kbd "C-d") 'comint-delchar-or-eof-or-kill-buffer)))

         ;; With this snippet, another press of C-d will kill the buffer.

         ;; It's pretty nice, since you then just tap C-d twice to get rid of the shell and go on about your merry way.


         ;; ;; Auto refresh buffers
         ;; (global-auto-revert-mode 1)

         ;; ;; Also auto refresh dired, but be quiet about it
         ;; (setq global-auto-revert-non-file-buffers t)
         ;; (setq auto-revert-verbose nil)

         ;; Auto revert mode looks for changes to files, and updates them for you.

         ;; With these settings, dired buffers are also updated. The last
         ;; setting makes sure that you're not alerted every time this happens.
         ;; Which is every time you save something.



         ))
    #+END_SRC
* Work Tools
  Some services I'm forced to use and integrate into emacs.
** Wiki
   #+BEGIN_SRC emacs-lisp
     (use-package dokuwiki
       :ensure t
       :defer t
       :config
       (setq dokuwiki-xml-rpc-url "http://192.168.3.132/dokuwiki/lib/exe/xmlrpc.php")
       (setq dokuwiki-login-user-name "povelleiro"))
   #+END_SRC

** Jira
   #+BEGIN_SRC emacs-lisp
     (use-package org-jira
       :ensure t
       :defer t
       :config
       (setq jiralib-url "https://desk.committance.com")
       )
   #+END_SRC
* Appearance

  Removes the menu,tool and scrollbars along with the splash-screen.

  #+BEGIN_SRC emacs-lisp
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (setq inhibit-splash-screen t)

    (global-hl-line-mode 1)                                ;; Highlight current line
    (setq-default display-line-numbers 'relative           ;; Display relative line-numbers
                  display-line-numbers-current-absolute t) ;; Show absolute line number for current line
    (show-paren-mode 1)                                    ;; Show matching parenthesis
    (setq show-paren-delay 0)                              ;; Show it immediately, don't delay
  #+END_SRC
** [[https://github.com/TheBB/spaceline][spaceline]]
   Show a nicer mode-line
   #+BEGIN_SRC emacs-lisp
     (use-package spaceline
 :ensure t
 :init
 (require 'spaceline-config)
 (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
 (setq powerline-default-separator 'slant)
 (setq evil-normal-state-tag "NORMAL")
 (setq evil-insert-state-tag "INSERT")
 (setq evil-visual-state-tag "VISUAL")
 (setq evil-emacs-state-tag "EMACS")
 :config
 (progn
	 (										;; spaceline-define-segment buffer-id
										 ;;  ( if (buffer-file-name)
										 ;;       (let ((project-root (projectile-project-p)))
										 ;;         (if project-root
										 ;;             (file-relative-name (buffer-file-name) project-root)
										 ;;           (abbreviate-file-name (buffer-file-name))))
										 ;;     (powerline-buffer-id)
										 ;; 	)
	   )
	 (spaceline-spacemacs-theme)
	 (spaceline-toggle-minor-modes-off)))
   #+END_SRC
** [[https://github.com/emacs-dashboard/emacs-dashboard][emacs-dashbord]]
   Display a startup dashboard
   #+BEGIN_SRC emacs-lisp
       (use-package dashboard
     :ensure t
     :config
     (dashboard-setup-startup-hook))
     (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
     (setq dashboard-items '((recents  . 5)
         (bookmarks . 5)
         (projects . 5)
         (agenda . 5)
         ;; (registers . 5)
     ))

     (setq dashboard-banner-logo-title "Happy hacking.")				;; Set the title
     (setq dashboard-startup-banner "~/.emacs.d/pc.png")				;; Set the banner
     (setq dashboard-center-content t)						;; Center content
     (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
   #+END_SRC

** [[https://github.com/tarsius/hl-todo][hl-todo]]

Minor mode for coloring TODO, NOTE, FIXME and many more keywords of
that sort prevalent in comments and strings.
#+BEGIN_SRC emacs-lisp
  ;; (use-package hl-todo
  ;; :ensure t
  ;; :config
  ;;  ((setq hl-todo-keyword-faces '(("TODO" . hl-todo)
  ;;                                 ("NOTE" . hl-todo)
  ;;                                 ("HACK" . hl-todo)
  ;;                                 ("FIXME" . hl-todo)
  ;;                                 ("KLUDGE" . hl-todo)))



  ;;   (with-eval-after-load 'hl-todo
  ;;     (hl-todo-set-regexp))
  ;;     (hl-todo-mode)
#+END_SRC
** Themes
   Also install some themes. I load gruvbox per default and switch sometimes.
   #+BEGIN_SRC emacs-lisp
     (use-package gruvbox-theme :ensure t :defer t)
     ;; (use-package base16-theme :ensure t :defer t)
     (load-theme 'gruvbox-dark-hard t)

     ;; (defun check-expansion ()
     ;;   (save-excursion
     ;;     (if (looking-at "\\_>") t
     ;;       (backward-char 1)
     ;;       (if (looking-at "\\.") t
     ;;         (backward-char 1)
     ;;         (if (looking-at "->") t nil)))))

     ;; (defun do-yas-expand ()
     ;;   (let ((yas/fallback-behavior 'return-nil))
     ;;     (yas/expand)))

     ;; (defun tab-indent-or-complete ()
     ;;   (interactive)
     ;;   (if (minibufferp)
     ;;       (minibuffer-complete)
     ;;     (if (or (not yas/minor-mode)
     ;;             (null (do-yas-expand)))
     ;;         (if (check-expansion)
     ;;             (company-complete-common)
     ;;           (indent-for-tab-command)))))

     ;; (global-set-key [tab] 'tab-indent-or-complete)

   #+END_SRC

* TODO
** Packaes I want to add/look into
*** TODO evil-textobj-between.el
*** TODO Add keybindings to jira-commands with general
*** TODO use global ensure
*** TODO password-store-el
** Some ideas (taken from https://medium.com/@CBowdon/pinching-the-best-bits-from-spacemacs-869b8c793ad3)
*** TODO Try eglot instaed of lsp-mode https://github.com/cbowdon/Config/blob/master/emacs/init.org
*** TODO A shortcut to edit my init file (a literate init file with Org mode, which is great).
*** TODO One key departure from Spacemacs:
    adding special modes like dired and VC to the evil-emacs-state-map, so that
    it uses the (usually consistent and mnemonic) default key bindings for those
    modes instead of mixing with Evil unpredictably.
*** TODO reference Spacemacs to get ideas for language-specific packages to install.


* Spell0cke
  #+BEGIN_SRC emacs-lisp



;; This buffer is for text that is not saved, and for Lisp evaluation.
;; To create a file, visit it with C-x C-f and enter text in its buffer.

(when (executable-find "hunspell")
  (setq-default ispell-program-name "hunspell")
  (setq ispell-really-hunspell t))


;; easy spell check
(global-set-key (kbd "<f8>") 'ispell-word)
(global-set-key (kbd "S-<f8>") 'flyspell-buffer)
(defun flyspell-check-next-highlighted-word ()
  "Custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (ispell-word)
  )
(global-set-key (kbd "M-<f8>") 'flyspell-check-next-highlighted-word)




(eval-after-load "flyspell"
  '(progn
     (defun flyspell-goto-next-and-popup ( )
       "Goto the next spelling error, popup menu, and stop when the end of buffer is reached."
       (interactive)
       (while (< (point) (point-max))
     (flyspell-goto-next-error)
     (redisplay)
     (flyspell-correct-word-before-point))
       (message "No more spelling errors in buffer.")
       )
     ))
(define-key flyspell-mode-map (kbd "C-<f8>") 'flyspell-goto-next-and-popup)



#+END_SRC


#+BEGIN_SRC emacs-lisp
(require 'cl)
(require 'dash)
(require 's)

(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
  `(propertize ,STR 'face (list ,@PROPS)))

(defmacro esh-section (NAME ICON FORM &rest PROPS)
  "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
  `(setq ,NAME
         (lambda () (when ,FORM
                 (-> ,ICON
                    (concat esh-section-delim ,FORM)
                    (with-face ,@PROPS))))))

(defun esh-acc (acc x)
  "Accumulator for evaluating and concatenating esh-sections."
  (--if-let (funcall x)
      (if (s-blank? acc)
          it
        (concat acc esh-sep it))
    acc))

(defun esh-prompt-func ()
  "Build `eshell-prompt-function'"
  (concat esh-header
          (-reduce-from 'esh-acc "" eshell-funcs)
          "\n"
          eshell-prompt-string))

(esh-section esh-dir
             "\xf07c"  ;  (faicon folder)
             (abbreviate-file-name (eshell/pwd))
             '(:foreground "gold" :bold ultra-bold :underline t))

(esh-section esh-git
             "\xe907"  ;  (git icon)
             (magit-get-current-branch)
             '(:foreground "pink"))

(esh-section esh-clock
             "\xf017"  ;  (clock icon)
             (format-time-string "%H:%M" (current-time))
             '(:foreground "forest green"))

;; Below I implement a "prompt number" section
(setq esh-prompt-num 0)
(add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
(advice-add 'eshell-send-input :before
            (lambda (&rest args) (setq esh-prompt-num (incf esh-prompt-num))))

(esh-section esh-num
             "\xf0c9"  ;  (list icon)
             (number-to-string esh-prompt-num)
             '(:foreground "brown"))

;; Separator between esh-sections
(setq esh-sep "  ")  ; or " | "

;; Separator between an esh-section icon and form
(setq esh-section-delim " ")

;; Eshell prompt header
(setq esh-header "\n ")  ; or "\n┌─"

;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
;; your login, these can be the same.
(setq eshell-prompt-regexp " ")   ; or "└─> "
(setq eshell-prompt-string " ")   ; or "└─> "

;; Choose which eshell-funcs to enable
(setq eshell-funcs (list esh-dir esh-git esh-clock esh-num))

;; Enable the new eshell prompt
(setq eshell-prompt-function 'esh-prompt-func)
(add-hook 'shell-mode-hook (lambda ()
                                                          (linum-mode -1)))

#+END_SRC

#+RESULTS:
: esh-prompt-func



# ;; This buffer is for text that is not saved, and for Lisp evaluation.
# ;; To create a file, visit it with C-x C-f and enter text in its buffer.


#     (defvar *echo-keys-last* nil "Last command processed by `echo-keys'.")

#     (defun echo-keys ()
#       (interactive)
#       (let ((deactivate-mark deactivate-mark))
#        (when (this-command-keys)
#          (with-current-buffer (get-buffer-create "*echo-key*")
#            (goto-char (point-max))
#            ;; self  self
#            ;; self  other \n
#            ;; other self  \n
#            ;; other other \n
#            (unless (and (eq 'self-insert-command *echo-keys-last*)
#                         (eq 'self-insert-command this-command))
#              (insert "\n"))
#            (if (eql this-command 'self-insert-command)
#                (let ((desc (key-description (this-command-keys))))
#                  (if (= 1 (length desc))
#                      (insert desc)
#                      (insert " " desc " ")))
#                (insert (key-description (this-command-keys))))
#            (setf *echo-keys-last* this-command)
#            (dolist (window (window-list))
#              (when (eq (window-buffer window) (current-buffer))
#                ;; We need to use both to get the effect.
#                (set-window-point window (point))
#                (end-of-buffer)))))))

#     (defun toggle-echo-keys ()
#       (interactive)
#       (if (member 'echo-keys  pre-command-hook)
#           (progn
#             (remove-hook 'pre-command-hook 'echo-keys)
#             (dolist (window (window-list))
#               (when (eq (window-buffer window) (get-buffer "*echo-key*"))
#                 (delete-window window))))
#           (progn
#             (add-hook    'pre-command-hook 'echo-keys)
#             (delete-other-windows)
#             (split-window nil (- (window-width) 32) t)
#             (other-window 1)
#             (switch-to-buffer (get-buffer-create "*echo-key*"))
#             (set-window-dedicated-p (selected-window) t)
#             (other-window 1))))


TODO bind swiper to /


#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'load-path "~/.emacs.d/lisp/")
  (let ((default-directory  "~/.emacs.d/lisp/"))
    (normal-top-level-add-subdirs-to-load-path))

#+END_SRC
